<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="LocalScript" referent="RBXABBEF83B6A5F41E081126B92D100F4C9">
		<Properties>
			<ProtectedString name="Source">if not game:IsLoaded() then
	game.Loaded:Wait()
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local Debris = game:GetService("Debris")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local GuiService = game:GetService("GuiService")
local StarterGui = game:GetService("StarterGui")
local Chat = game:GetService("Chat")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local playerGui = player:WaitForChild("PlayerGui")

local replicatedModules = ReplicatedStorage:WaitForChild("Modules")

local WindLines = require(script:WaitForChild("WindLines"))
local living = workspace.Live

local function safeRequireFromReplicated(path)
	local node = ReplicatedStorage
	for _, name in ipairs(path) do
		node = node:WaitForChild(name)
	end

	local ok, result = pcall(require, node)
	if not ok then
		warn(("[ClientHandler] require failed for %s: %s"):format(table.concat(path, "."), tostring(result)))
		return nil
	end

	return result
end

local function safeInit(mod, name)
	if not mod then
		return
	end
	if typeof(mod.Init) ~= "function" then
		return
	end

	local ok, err = pcall(mod.Init, mod)
	if not ok then
		warn(("[ClientHandler] %s.Init failed: %s"):format(name, tostring(err)))
	end
end

safeInit(safeRequireFromReplicated({ "LocalHandler", "Misc", "TopbarButtons" }), "TopbarButtons")
safeInit(safeRequireFromReplicated({ "LocalHandler", "Misc", "CoreGuiConfig" }), "CoreGuiConfig")
safeInit(safeRequireFromReplicated({ "LocalHandler", "Misc", "Visuals", "WorldDropVisuals" }), "WorldDropVisuals")

GuiService:SetGameplayPausedNotificationEnabled(false)

local cameraTracker = Instance.new("Part")
cameraTracker.CanCollide = false
cameraTracker.Anchored = true
cameraTracker.Massless = true
cameraTracker.Name = "CameraTracker"
cameraTracker.Transparency = 1
cameraTracker.Size = Vector3.new(0.05, 0.05, 0.05)
cameraTracker.Parent = workspace.Terrain

local cameraInWater = false

local cameraCheckParams = OverlapParams.new()
cameraCheckParams.FilterDescendantsInstances = { cameraTracker }
cameraCheckParams.FilterType = Enum.RaycastFilterType.Include
cameraCheckParams.RespectCanCollide = false

local mapCheckParams = RaycastParams.new()
mapCheckParams.FilterDescendantsInstances = { workspace.World.Map }
mapCheckParams.FilterType = Enum.RaycastFilterType.Include
mapCheckParams.RespectCanCollide = true

local oldTemp = 0

local snowyAreas = {
	"The Frostfalls",
	"The Expeditioner's Keep",
	"Bishoped Ruins",
	"King's Ray",
}

local seekerAreas = {
	"Seeker's Watch",
	"The All-Seeing Eye",
}

local indoors = false
local rotationSpeed = math.rad(0.6)
local prevWaterUpdate = tick()
local prevWindUpdate = tick()

RunService.RenderStepped:connect(function(deltaTime)
	local rootPos = player.Character
			and player.Character:FindFirstChild("HumanoidRootPart")
			and player.Character.HumanoidRootPart.Position
		or Vector3.zero
	cameraTracker.CFrame = workspace.CurrentCamera.CFrame

	local ray = workspace:Raycast(rootPos, Vector3.new(0, 1000, 0), mapCheckParams)
	if ray and ray.Instance then
		if not indoors then
			--print'now indoors'
			indoors = true
			WindLines:Cleanup()
		end
	else
		if indoors then
			--print'no longer indoors'
			indoors = false
			WindLines:Init({
				Direction = Vector3.new(1.2, 0, 0),
				Speed = 12.5,
				Lifetime = 5,
				SpawnRate = 2.5,
			})
		end
	end
end)
</ProtectedString>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{456307A0-A381-49A9-8B48-0A1EC2490C1C}</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">ClientHandler</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXDF32EA0919F846AAB1A0F23BC73F4647">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Terrain = workspace:FindFirstChildOfClass("Terrain")

local EMPTY_TABLE = {}
local OFFSET = Vector3.new(0, 0.1, 0)

local module = {}

module.UpdateQueue = table.create(10)

function module:Init(Settings)
	-- Set defaults
	module.Lifetime = Settings.Lifetime or 3
	module.Direction = Settings.Direction or Vector3.new(1, 0, 0)
	module.Speed = Settings.Speed or 6

	-- Clear any old stuff
	if module.UpdateConnection then
		module.UpdateConnection:Disconnect()
		module.UpdateConnection = nil
	end

	for _, WindLine in ipairs(module.UpdateQueue) do
		WindLine.Attachment0:Destroy()
		WindLine.Attachment1:Destroy()
		WindLine.Trail:Destroy()
	end
	table.clear(module.UpdateQueue)

	module.LastSpawned = os.clock()
	local SpawnRate = 1 / (Settings.SpawnRate or 25)

	-- Setup logic loop
	module.UpdateConnection = RunService.RenderStepped:Connect(function()
		local Clock = os.clock()

		-- Spawn handler
		if Clock - module.LastSpawned > SpawnRate then
			module:Create()
			module.LastSpawned = Clock
		end

		-- Update queue handler
		debug.profilebegin("Wind Lines")
		for i, WindLine in ipairs(module.UpdateQueue) do
			local AliveTime = Clock - WindLine.StartClock
			if AliveTime >= WindLine.Lifetime then
				-- Destroy the objects
				WindLine.Attachment0:Destroy()
				WindLine.Attachment1:Destroy()
				WindLine.Trail:Destroy()

				-- unordered remove at this index
				local Length = #module.UpdateQueue
				module.UpdateQueue[i] = module.UpdateQueue[Length]
				module.UpdateQueue[Length] = nil

				continue
			end

			WindLine.Trail.MaxLength = 20 - (20 * (AliveTime / WindLine.Lifetime))

			local SeededClock = (Clock + WindLine.Seed) * (WindLine.Speed * 0.2)
			local StartPos = WindLine.Position
			WindLine.Attachment0.WorldPosition = (CFrame.new(StartPos, StartPos + WindLine.Direction) * CFrame.new(
				0,
				0,
				WindLine.Speed * -AliveTime
			)).Position + Vector3.new(
				math.sin(SeededClock) * 0.5,
				math.sin(SeededClock) * 0.8,
				math.sin(SeededClock) * 0.5
			)

			WindLine.Attachment1.WorldPosition = WindLine.Attachment0.WorldPosition + OFFSET
		end
		debug.profileend()
	end)
end

function module:Cleanup()
	if module.UpdateConnection then
		module.UpdateConnection:Disconnect()
		module.UpdateConnection = nil
	end

	for _, WindLine in ipairs(module.UpdateQueue) do
		WindLine.Attachment0:Destroy()
		WindLine.Attachment1:Destroy()
		WindLine.Trail:Destroy()
	end
	table.clear(module.UpdateQueue)
end

function module:Create(Settings)
	debug.profilebegin("Add Wind Line")

	Settings = Settings or EMPTY_TABLE

	local Lifetime = Settings.Lifetime or module.Lifetime
	local Position = Settings.Position
		or (
				workspace.CurrentCamera.CFrame
				* CFrame.Angles(math.rad(math.random(-30, 70)), math.rad(math.random(-80, 80)), 0)
			)
			* CFrame.new(0, 0, math.random(200, 600) * -0.1).Position
	local Direction = Settings.Direction or module.Direction
	local Speed = Settings.Speed or module.Speed
	if Speed <= 0 then
		return
	end

	local Attachment0 = Instance.new("Attachment")
	local Attachment1 = Instance.new("Attachment")

	local Trail = Instance.new("Trail")
	Trail.Attachment0 = Attachment0
	Trail.Attachment1 = Attachment1
	Trail.WidthScale = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(0.2, 1),
		NumberSequenceKeypoint.new(0.8, 1),
		NumberSequenceKeypoint.new(1, 0.5),
	})
	Trail.Texture = "rbxassetid://5699911427"
	Trail.Transparency = NumberSequence.new(0.45)
	Trail.FaceCamera = true
	Trail.Parent = Attachment0

	Attachment0.WorldPosition = Position
	Attachment1.WorldPosition = Position + OFFSET

	local WindLine = {
		Attachment0 = Attachment0,
		Attachment1 = Attachment1,
		Trail = Trail,
		Lifetime = Lifetime + (math.random(-10, 10) * 0.1),
		Position = Position,
		Direction = Direction,
		Speed = Speed + (math.random(-10, 10) * 0.1),
		StartClock = os.clock(),
		Seed = math.random(1, 1000) * 0.1,
	}

	module.UpdateQueue[#module.UpdateQueue + 1] = WindLine

	Attachment0.Parent = Terrain
	Attachment1.Parent = Terrain

	debug.profileend()
end

return module
]]></ProtectedString>
				<string name="ScriptGuid">{8A74FC79-5918-4441-8EB2-F67B5D24F349}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">WindLines</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>
